#!/opt/pwn.college/python

import flask
import os

app = flask.Flask(__name__)


import pathlib
import psutil


# This function retrieves the path of the process that is on the
# other side of the file descriptor we pass in.
def peer_path(fd):
    server_connection = next(connection for connection in psutil.Process().connections() if connection.fd == fd)
    client_connection = next(
        connection
        for connection in psutil.net_connections()
        if connection.raddr == server_connection.laddr and connection.laddr == server_connection.raddr
    )
    client_process = psutil.Process(client_connection.pid)
    return client_process.exe()


# This function returns the filename of a peer process for a given
# file descriptor, verifying that the path is owned by root and
# not open to shenanigans.
def trusted_peer_name(fd):
    client_path = pathlib.Path(peer_path(fd))
    for p in reversed(client_path.parents):
        if not p.owner() == "root":
            return None
        if p in ("/home", "/tmp", "/var/tmp", "/dev/shm"):
            return None
    return client_path.stem


@app.route("/task", methods=["GET"])
def challenge():
    if trusted_peer_name(flask.request.input_stream.fileno()) not in ["nc"]:
        flask.abort(400, "You are using an incorrect client to access this resource!")

    response = flask.make_response(
        "<html><head><title>Talking Web</title></head><body><h1>Great job!</h1></body></html>"
    )
    response.headers["X-Flag"] = open("/flag").read().strip()
    return response


app.secret_key = os.urandom(8)
app.config["SERVER_NAME"] = "pwnable.kr:80"
app.run("challenge.localhost", 80)
